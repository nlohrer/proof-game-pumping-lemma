msgid ""
msgstr "Project-Id-Version: Game v4.7.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: Tue Jul 22 15:56:07 2025\n"
"Last-Translator: \n"
"Language-Team: none\n"
"Language: en\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit"

#: GameServer.RpcHandlers
msgid "level completed! ğŸ‰"
msgstr ""

#: GameServer.RpcHandlers
msgid "level completed with warningsâ€¦ ğŸ­"
msgstr ""

#: GameServer.RpcHandlers
msgid "intermediate goal solved! ğŸ‰"
msgstr ""

#: Game.Levels.LeanBasics.L01_rfl
msgid "rfl"
msgstr ""

#: Game.Levels.LeanBasics.L01_rfl
msgid "# Introduction\n"
"Let's look at some of the very basics of Lean.\n"
"## Proof state\n"
"In the middle bottom of the screen, you'll find the proof state, which includes\n"
"both the goal of the proof, as well as all objects and assumptions that you may\n"
"use to arrive at the proof.\n"
"## rfl\n"
"The `rfl` tactic closes the goal with pure reflexivity."
msgstr ""

#: Game.Levels.LeanBasics.L01_rfl
msgid "Use `rfl` to close the goal immediately."
msgstr ""

#: Game.Levels.LeanBasics.L01_rfl
msgid "Good! `rfl` isn't required very often, but we do need it sometimes."
msgstr ""

#: Game.Levels.LeanBasics.L02_exact
msgid "exact"
msgstr ""

#: Game.Levels.LeanBasics.L02_exact
msgid "# exact\n"
"whenever a hypothesis matches the goal precisely, we can use `exact` to close out the goal."
msgstr ""

#: Game.Levels.LeanBasics.L02_exact
msgid "Use `exact Â«{h}Â»` to close the goal immediately."
msgstr ""

#: Game.Levels.LeanBasics.L02_exact
msgid "Good!"
msgstr ""

#: Game.Levels.LeanBasics.L03_Third
msgid "Third Level"
msgstr ""

#: Game.Levels.LeanBasics.L03_Third
msgid "# Introduction\n"
"In this level, we'll be looking at..."
msgstr ""

#: Game.Levels.LeanBasics.L03_Third
msgid "You can either abc start using"
msgstr ""

#: Game.Levels.LeanBasics.L03_Third
msgid "You should use `Â«{h}Â»` now."
msgstr ""

#: Game.Levels.LeanBasics.L03_Third
msgid "You should use `Â«{g}Â»` now."
msgstr ""

#: Game.Levels.LeanBasics.L03_Third
msgid "This last message appears if the level is solved."
msgstr ""

#: Game.Levels.LeanBasics.L04_intro
msgid "exact"
msgstr ""

#: Game.Levels.LeanBasics.L04_intro
msgid "# intro\n"
"We use the `intro` tactic to handle both `âˆ€`-statements, and to introduce the antecedent\n"
"of an implication."
msgstr ""

#: Game.Levels.LeanBasics.L04_intro
msgid "start with `intro A`"
msgstr ""

#: Game.Levels.LeanBasics.L04_intro
msgid "Now, `intro ha` will introduce the antecedent into our given hypotheses."
msgstr ""

#: Game.Levels.LeanBasics.L04_intro
msgid "Good!"
msgstr ""

#: Game.Levels.LeanBasics.L05_apply
msgid "apply"
msgstr ""

#: Game.Levels.LeanBasics.L05_apply
msgid "# apply\n"
"whenever a hypothesis matches the goal precisely, we can use `exact` to close out the goal."
msgstr ""

#: Game.Levels.LeanBasics.L05_apply
msgid "Use `apply Â«{hAB}Â» at Â«{hA}Â»`."
msgstr ""

#: Game.Levels.LeanBasics.L05_apply
msgid "`exact Â«{hA}Â»` will close the goal now."
msgstr ""

#: Game.Levels.LeanBasics.L05_apply
msgid "Good!"
msgstr ""

#: Game.Levels.LeanBasics.L06_have
msgid "have"
msgstr ""

#: Game.Levels.LeanBasics.L06_have
msgid "# have\n"
"Sometimes, we want to construct sub-hypotheses of our own. We can do this with the\n"
"`have` tactic."
msgstr ""

#: Game.Levels.LeanBasics.L06_have
msgid "Use `exact Â«{h}Â»` to close the goal immediately"
msgstr ""

#: Game.Levels.LeanBasics.L06_have
msgid "Good!"
msgstr ""

#: Game.Levels.LeanBasics.L07_clear
msgid "exact"
msgstr ""

#: Game.Levels.LeanBasics.L07_clear
msgid "# clear\n"
"Sometimes, especially when proving a lemma via `have`, the proof state might include a\n"
"lot of hypotheses that are not necessary to achieve the current goal. To keep them from\n"
"distracting us, we can use the `clear` tactic to remove them."
msgstr ""

#: Game.Levels.LeanBasics.L07_clear
msgid "Use `clear Â«{a}Â» Â«{b}Â» Â«{c}Â» Â«{d}Â» Â«{e}Â» Â«{f}Â» Â«{hy}Â» Â«{hz}Â» Â«{y}Â» Â«{z}Â»` to remove the unneeded hypotheses"
msgstr ""

#: Game.Levels.LeanBasics.L07_clear
msgid "Good!"
msgstr ""

#: Game.Levels.LeanBasics.L08_constructor
msgid "exact"
msgstr ""

#: Game.Levels.LeanBasics.L08_constructor
msgid "# Induction\n"
"To work through certain structures, the `constructor` can be useful."
msgstr ""

#: Game.Levels.LeanBasics.L08_constructor
msgid "Use `constructor` to split the conjunction we want to prove into two separate goals."
msgstr ""

#: Game.Levels.LeanBasics.L08_constructor
msgid "Good!"
msgstr ""

#: Game.Levels.LeanBasics.L09_induction
msgid "exact"
msgstr ""

#: Game.Levels.LeanBasics.L09_induction
msgid "# Induction\n"
"We utilize several inductive structures that we can handle with the `induction'` tactic."
msgstr ""

#: Game.Levels.LeanBasics.L09_induction
msgid "Use `induction' Â«{n}Â» with n ih` to start a proof by induction"
msgstr ""

#: Game.Levels.LeanBasics.L09_induction
msgid "Good!"
msgstr ""

#: Game.Levels.LeanBasics.L10_match
msgid "exact"
msgstr ""

#: Game.Levels.LeanBasics.L10_match
msgid "# match\n"
"For some structures, we might just need to match the forms that they can appear in."
msgstr ""

#: Game.Levels.LeanBasics.L10_match
msgid "Use `exact Â«{h}Â»` to close the goal immediately"
msgstr ""

#: Game.Levels.LeanBasics.L10_match
msgid "Good!"
msgstr ""

#: Game.Levels.LeanBasics.L11_simp_only
msgid "exact"
msgstr ""

#: Game.Levels.LeanBasics.L11_simp_only
msgid "# simp only\n"
"whenever a hypothesis matches the goal precisely, we can use `exact` to close out the goal."
msgstr ""

#: Game.Levels.LeanBasics.L11_simp_only
msgid "Use `exact Â«{h}Â»` to close the goal immediately"
msgstr ""

#: Game.Levels.LeanBasics.L11_simp_only
msgid "Good!"
msgstr ""

#: Game.Levels.LeanBasics.L12_simp_all_only
msgid "exact"
msgstr ""

#: Game.Levels.LeanBasics.L12_simp_all_only
msgid "# simp_all only\n"
"whenever a hypothesis matches the goal precisely, we can use `exact` to close out the goal."
msgstr ""

#: Game.Levels.LeanBasics.L12_simp_all_only
msgid "Use `exact Â«{h}Â»` to close the goal immediately"
msgstr ""

#: Game.Levels.LeanBasics.L12_simp_all_only
msgid "Good!"
msgstr ""

#: Game.Levels.LeanBasics.L13_omega
msgid "omega"
msgstr ""

#: Game.Levels.LeanBasics.L13_omega
msgid "# omega\n"
"The tactic `omega` can solve integer and natural linear arithmetic problems."
msgstr ""

#: Game.Levels.LeanBasics.L13_omega
msgid "Use `omega` to close the goal immediately"
msgstr ""

#: Game.Levels.LeanBasics.L13_omega
msgid "Good!"
msgstr ""

#: Game.Levels.LeanBasics.L14_split_ifs
msgid "split_ifs"
msgstr ""

#: Game.Levels.LeanBasics.L14_split_ifs
msgid "# omega\n"
"The tactic `omega` can solve integer and natural linear arithmetic problems."
msgstr ""

#: Game.Levels.LeanBasics.L14_split_ifs
msgid "Good!"
msgstr ""

#: Game.Levels.LeanBasics
msgid "Lean Basics"
msgstr ""

#: Game.Levels.LeanBasics
msgid "This introductory part serves as a refresher for Lean."
msgstr ""

#: Game.Levels.Lemmas.L01_Introduction
msgid "First Lemma"
msgstr ""

#: Game.Levels.Lemmas.L01_Introduction
msgid "This text is shown as first message when the level is played.\n"
"You can insert hints in the proof below. They will appear in this side panel\n"
"depending on the proof a user provides."
msgstr ""

#: Game.Levels.Lemmas.L01_Introduction
msgid "You can lemma either start using `Â«{h}Â»` or `Â«{g}Â»`."
msgstr ""

#: Game.Levels.Lemmas.L01_Introduction
msgid "You should use `Â«{h}Â»` now."
msgstr ""

#: Game.Levels.Lemmas.L01_Introduction
msgid "You should use `Â«{g}Â»` now."
msgstr ""

#: Game.Levels.Lemmas.L01_Introduction
msgid "This last message appears if the level is solved."
msgstr ""

#: Game.Levels.Lemmas.L02_cat_eps
msgid "cat_eps"
msgstr ""

#: Game.Levels.Lemmas.L02_cat_eps
msgid "Let's prove a simple lemma: concatenating any word with the empty word should yield the word itself."
msgstr ""

#: Game.Levels.Lemmas.L02_cat_eps
msgid "Concatenating a word with Îµ yields the original word."
msgstr ""

#: Game.Levels.Lemmas.L02_cat_eps
msgid "Concatenation of words: for two words wâ‚ and wâ‚‚, the concatenation wâ‚ and wâ‚‚ yields wâ‚wâ‚‚."
msgstr ""

#: Game.Levels.Lemmas.L02_cat_eps
msgid "A word over an alphabet, i.e. a string of symbols from that alphabet."
msgstr ""

#: Game.Levels.Lemmas.L02_cat_eps
msgid "Good!"
msgstr ""

#: Game.Levels.Lemmas.L03_cat_assoc
msgid "cat_assoc"
msgstr ""

#: Game.Levels.Lemmas.L03_cat_assoc
msgid "Let's prove another basic lemma: concatenation is associative."
msgstr ""

#: Game.Levels.Lemmas.L03_cat_assoc
msgid "Concatenation of words is associative, e.g. (x âˆ˜ y) âˆ˜ z = x âˆ˜ (y âˆ˜ z)."
msgstr ""

#: Game.Levels.Lemmas.L03_cat_assoc
msgid "Good! Incidentally, we've just shown that strings together with concatenation form a monoid."
msgstr ""

#: Game.Levels.Lemmas.L04_gap
msgid "cat_assoc"
msgstr ""

#: Game.Levels.Lemmas.L04_gap
msgid "Let's prove a simple lemma: concatenating any word with the empty word should yield the word itself."
msgstr ""

#: Game.Levels.Lemmas.L04_gap
msgid "Good!"
msgstr ""

#: Game.Levels.Lemmas.L05_cat_count
msgid "assoc_count"
msgstr ""

#: Game.Levels.Lemmas.L05_cat_count
msgid "We've just introduced the `count` definition, which counts how many times a certain character occurs in a word. Let's show that we can get the count for a character in a word by summing up the counts in its subwords."
msgstr ""

#: Game.Levels.Lemmas.L05_cat_count
msgid "for the concatenation of two words, counting the occurrences of a certain character in the entire word\n"
"is the same as counting the occurrences in both subwords and adding them up."
msgstr ""

#: Game.Levels.Lemmas.L05_cat_count
msgid "Counts how often a character occurs in a word."
msgstr ""

#: Game.Levels.Lemmas.L05_cat_count
msgid "Good!"
msgstr ""

#: Game.Levels.Lemmas.L06_cat_count_zero
msgid "cat_count_zero"
msgstr ""

#: Game.Levels.Lemmas.L06_cat_count_zero
msgid "We'll need a special case of the lemma we just showed later on: when a certain character does not occur in a word, it won't appear in any of its subwords either."
msgstr ""

#: Game.Levels.Lemmas.L06_cat_count_zero
msgid "If a symbol doesn't occur in the concatenation of two words, then it won't occur in any of the two words either."
msgstr ""

#: Game.Levels.Lemmas.L06_cat_count_zero
msgid "Good!"
msgstr ""

#: Game.Levels.Lemmas.L07_cat_len
msgid "cat_len"
msgstr ""

#: Game.Levels.Lemmas.L07_cat_len
msgid "Our new definition `length` defines the length of a word. Let's show that the length of a word is equal to the sum of its subwords."
msgstr ""

#: Game.Levels.Lemmas.L07_cat_len
msgid "To determine the length of the concatenation of two words, you can add the length of both words."
msgstr ""

#: Game.Levels.Lemmas.L07_cat_len
msgid "The amount of symbols in a word."
msgstr ""

#: Game.Levels.Lemmas.L07_cat_len
msgid "Good!"
msgstr ""

#: Game.Levels.Lemmas.L08_pow_len
msgid "pow_len"
msgstr ""

#: Game.Levels.Lemmas.L08_pow_len
msgid "The `pow` definition allows us to create strings of the form aâ¿, such as aâ´ = aaaa. We want to show that aâ¿ is n characters long."
msgstr ""

#: Game.Levels.Lemmas.L08_pow_len
msgid "The length of câ¿ is n for any character c."
msgstr ""

#: Game.Levels.Lemmas.L08_pow_len
msgid "The power of a symbol: aâ¿ = a...a repeated n times."
msgstr ""

#: Game.Levels.Lemmas.L08_pow_len
msgid "Good!"
msgstr ""

#: Game.Levels.Lemmas.L09_pow_count
msgid "pow_count"
msgstr ""

#: Game.Levels.Lemmas.L09_pow_count
msgid "For our last lemma, we will show that for a word of the form câ¿, it will contain n instances of c, and none of any other character."
msgstr ""

#: Game.Levels.Lemmas.L09_pow_count
msgid "A word of the form câ¿ will contain n instances of the character c, and none of any other character."
msgstr ""

#: Game.Levels.Lemmas.L09_pow_count
msgid "Good!"
msgstr ""

#: Game.Levels.Lemmas
msgid "Lemmas"
msgstr ""

#: Game.Levels.Lemmas
msgid "Some lemmas that will be useful later on."
msgstr ""

#: Game.Levels.NonregProofs.L01_First
msgid "First Proof"
msgstr ""

#: Game.Levels.NonregProofs.L01_First
msgid "This text is shown as first message when the level is played.\n"
"You can insert hints in the proof below. They will appear in this side panel\n"
"depending on the proof a user provides."
msgstr ""

#: Game.Levels.NonregProofs.L01_First
msgid "You can first nonreg either start using `Â«{h}Â»` or `Â«{g}Â»`."
msgstr ""

#: Game.Levels.NonregProofs.L01_First
msgid "You should use `Â«{h}Â»` now."
msgstr ""

#: Game.Levels.NonregProofs.L01_First
msgid "You should use `Â«{g}Â»` now."
msgstr ""

#: Game.Levels.NonregProofs.L01_First
msgid "This last message appears if the level is solved."
msgstr ""

#: Game.Levels.NonregProofs.L02_Proof
msgid "Proving the nonregularity of aâ¿bâ¿"
msgstr ""

#: Game.Levels.NonregProofs.L02_Proof
msgid "We are finally ready to work through a proof that utilizes the pumping lemma!\n"
"The proof on paper is as follows:\n"
"-\n"
"...\n"
"-\n"
"\n"
"We will want to replicate the structure of the proof in Lean, but it will turn out\n"
"that some of the steps are far more difficult to realize than on paper. Therefore,\n"
"we will mostly guide you through each of the individual steps; you should therefore\n"
"try to follow the instructions closely, as later steps might be contingent on earlier\n"
"ones so that the proof state is in a fitting form."
msgstr ""

#: Game.Levels.NonregProofs.L02_Proof
msgid "Let's first `rw [pumping_property]` to recall the definition of the pumping\n"
"property, then `push_neg` to push the negation all the way in."
msgstr ""

#: Game.Levels.NonregProofs.L02_Proof
msgid "We can now replicate the initial 'let n > 0' part of the proof with `intro n hpos`."
msgstr ""

#: Game.Levels.NonregProofs.L02_Proof
msgid "The word we want to use is z = aâ¿bâ¿.\n"
"Let's introduce it with `let z : Word := 'a' ^+^ Â«{n}Â» âˆ˜ 'b' ^+^ Â«{n}Â»`"
msgstr ""

#: Game.Levels.NonregProofs.L02_Proof
msgid "We will need to show that z is actually an element of the language anbn in\n"
"a second, so let's introduce that as a new hypothesis: `have hzinanbn : z âˆˆ anbn`."
msgstr ""

#: Game.Levels.NonregProofs.L02_Proof
msgid "After rewriting with `anbn` and `Set.mem_setOf_eq`, we can just `use n`."
msgstr ""

#: Game.Levels.NonregProofs.L02_Proof
msgid "`use z`"
msgstr ""

#: Game.Levels.NonregProofs.L02_Proof
msgid "`constructor` will split the conjunction into separate proofs."
msgstr ""

#: Game.Levels.NonregProofs.L02_Proof
msgid "`exact Â«{hzinanbn}Â»` closes the goal directly."
msgstr ""

#: Game.Levels.NonregProofs.L02_Proof
msgid "Since we're using an earlier Lean version for several reasons, we don't\n"
"have access to the `set` tactic, which would have given us a hypothesis that\n"
"`Â«{z}Â»` is indeed equal to aâ¿bâ¿. However, we introduced `Â«{z}Â»` with the `let` tactic,\n"
"so we will need to prove that hypothesis separately:\n"
"\n"
"`have heq : Â«{z}Â» = 'a' ^+^ n âˆ˜ 'b' ^+^ n := rfl`"
msgstr ""

#: Game.Levels.NonregProofs.L02_Proof
msgid "We once again use `constructor` to handle the conjunction."
msgstr ""

#: Game.Levels.NonregProofs.L02_Proof
msgid "We need to show that the length of z is indeed greater than n. You can\n"
"`rw` step by step with some of the lemmas that we showed in the previous world,\n"
"and then use the `omega` tactic once you arrive at a proof state of the form\n"
"`n + n > n`."
msgstr ""

#: Game.Levels.NonregProofs.L02_Proof
msgid "The exact hypotheses for rewriting that you should use\n"
"are `Â«{heq}Â»`, `Word.cat_len`, `Symbol.pow_len`, and `Symbol.pow_len` again."
msgstr ""

#: Game.Levels.NonregProofs.L02_Proof
msgid "We can finally get to the main part of the proof! First of all, we need\n"
"to introduce all the conditions that we also introduce in the paper proof:\n"
"\n"
"`intro u v w hcons hlenlower hv`"
msgstr ""

#: Game.Levels.NonregProofs.L02_Proof
msgid "Let's look at our hypotheses: ...\n"
"\n"
"We now need to provide a suitable `i`; in the paper proof we set `i := 2`,\n"
"so let's `use 2`."
msgstr ""

#: Game.Levels.NonregProofs.L02_Proof
msgid "In our paper proof, we made an argument for why there are no b's in `Â«{v}Â»`. For our formalization, let's have this as a separate hypothesis:\n"
"\n"
"`have honlyas: Â«{v}Â».count 'b' = 0`"
msgstr ""

#: Game.Levels.NonregProofs.L02_Proof
msgid "Let's simplify the entire proof state with\n"
"`simp_all only [gt_iff_lt, Â«{z}Â», â†“Char.isValue]`"
msgstr ""

#: Game.Levels.NonregProofs.L02_Proof
msgid "The argument in our proof works to show that there are no b's in\n"
"`uv`. Let's show that first: `have huv : (u âˆ˜ v).count 'b' = 0`."
msgstr ""

#: Game.Levels.NonregProofs.L02_Proof
msgid "We need to utilize the associativity that we proved earlier:\n"
"\n"
"`rw [â† Word.cat_assoc]`\n"
"\n"
"Following that, use the tactic `symm at Â«{hcons}Â»`"
msgstr ""

#: Game.Levels.NonregProofs.L02_Proof
msgid "For this specific situation, the lemma `Word.cons_a` is already provided to us, so you can finish the subproof with\n"
"\n"
"`apply Word.cons_a Â«{n}Â» (Â«{u}Â» âˆ˜ Â«{v}Â») Â«{w}Â» ('b' ^+^ Â«{n}Â») Â«{hcons}Â» Â«{hlenlower}Â»`"
msgstr ""

#: Game.Levels.NonregProofs.L02_Proof
msgid "We can now use the fresh hypothesis `Â«{huv}Â»`:\n"
"\n"
"`exact (@Word.cat_count_zero 'b' Â«{u}Â» Â«{v}Â» Â«{huv}Â»).right`"
msgstr ""

#: Game.Levels.NonregProofs.L02_Proof
msgid "For the next step of our proof, we showed that `Â«{v}Â»` contained at least\n"
"one 'a'. This will unfortunately be much more involved to show!"
msgstr ""

#: Game.Levels.NonregProofs.L02_Proof
msgid "This last message appears if the level is solved."
msgstr ""

#: Game.Levels.NonregProofs
msgid "Nonregularity Proofs"
msgstr ""

#: Game.Levels.NonregProofs
msgid "The proofs themselves"
msgstr ""

#: Game
msgid "Pumping Lemma Game"
msgstr ""

#: Game
msgid "This text appears on the starting page where one selects the world/level to play.\n"
"You can use markdown."
msgstr ""

#: Game
msgid "Here you can put additional information about the game. It is accessible\n"
"from the starting through the drop-down menu.\n"
"\n"
"For example: Game version, Credits, Link to Github and Zulip, etc.\n"
"\n"
"Use markdown."
msgstr ""

#: Game
msgid "Game Template"
msgstr ""

#: Game
msgid "You should use this game as a template for your own game and add your own levels."
msgstr ""
