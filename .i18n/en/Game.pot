msgid ""
msgstr "Project-Id-Version: Game v4.7.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: Wed Sep  3 20:21:35 2025\n"
"Last-Translator: \n"
"Language-Team: none\n"
"Language: en\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit"

#: GameServer.RpcHandlers
msgid "level completed! 🎉"
msgstr ""

#: GameServer.RpcHandlers
msgid "level completed with warnings… 🎭"
msgstr ""

#: GameServer.RpcHandlers
msgid "intermediate goal solved! 🎉"
msgstr ""

#: Game.Levels.LeanBasics.L01_rfl
msgid "rfl"
msgstr ""

#: Game.Levels.LeanBasics.L01_rfl
msgid "# Introduction\n"
"Let's look at some of the very basics of Lean.\n"
"\n"
"## Proof state\n"
"In the middle bottom of the screen, you'll find the proof state, which includes\n"
"both the goal of the proof, as well as all objects and assumptions that you may\n"
"use to arrive at the proof.\n"
"\n"
"## rfl\n"
"The `rfl` tactic closes the goal using reflexivity."
msgstr ""

#: Game.Levels.LeanBasics.L01_rfl
msgid "Use `rfl` to close the goal immediately."
msgstr ""

#: Game.Levels.LeanBasics.L01_rfl
msgid "Good! `rfl` isn't required very often, but we do need it sometimes."
msgstr ""

#: Game.Levels.LeanBasics.L02_exact
msgid "exact"
msgstr ""

#: Game.Levels.LeanBasics.L02_exact
msgid "# exact\n"
"Whenever a hypothesis matches the goal precisely, we can use `exact` to close out the goal."
msgstr ""

#: Game.Levels.LeanBasics.L02_exact
msgid "Use `exact «{h}»` to close the goal immediately."
msgstr ""

#: Game.Levels.LeanBasics.L02_exact
msgid "`exact` will often be useful to close out a (sub-)goal."
msgstr ""

#: Game.Levels.LeanBasics.L03_rw
msgid "rw"
msgstr ""

#: Game.Levels.LeanBasics.L03_rw
msgid "# rw\n"
"The `rw` tactic allows for rewriting using certain theorems or hypotheses,\n"
"both at the goal as well as at specific hypotheses."
msgstr ""

#: Game.Levels.LeanBasics.L03_rw
msgid "As we can see, both `«{h}»` and `«{k}»` are currently stated a bit awkwardly. Start with `rw [«{g}»] at «{h}» «{k}»`."
msgstr ""

#: Game.Levels.LeanBasics.L03_rw
msgid "The goal now follows from `«{h}»` and `«{k}»` quite directly.\n"
"You can't use `exact` or `rfl` in this level, but `rw` will try to close out\n"
"the goal anyway using reflexivity.\n"
"`rw [← «{h}», «{k}»]` closes the goal immediately. Mind that we write\n"
"`← «{h}»` since `rw` usually substitutes a term matching the left side of the equation with the one on the right side. The equality `«{h}»` is in the opposite direction of the rewrite we wish to apply, so we use `←` (which can\n"
"be typed with `\\l`) to reverse it."
msgstr ""

#: Game.Levels.LeanBasics.L03_rw
msgid "From here `rw [«{k}»]` closes the goal."
msgstr ""

#: Game.Levels.LeanBasics.L03_rw
msgid "There are some more syntactic specifics when it comes to using `rw`,\n"
"but we will not need them in the future."
msgstr ""

#: Game.Levels.LeanBasics.L04_intro
msgid "intro"
msgstr ""

#: Game.Levels.LeanBasics.L04_intro
msgid "# intro\n"
"We use the `intro` tactic to handle both `∀`-statements, and to introduce the antecedent\n"
"of an implication."
msgstr ""

#: Game.Levels.LeanBasics.L04_intro
msgid "start with `intro A`"
msgstr ""

#: Game.Levels.LeanBasics.L04_intro
msgid "Now, `intro ha` will introduce the antecedent into our given hypotheses."
msgstr ""

#: Game.Levels.LeanBasics.L04_intro
msgid "`exact «{ha}»` closes the goal."
msgstr ""

#: Game.Levels.LeanBasics.L04_intro
msgid "Using `intro x y...` will be equivalent to steps such as \"\n"
"Let x be arbitrary...\", or \"Assume y...\" in a paper proof."
msgstr ""

#: Game.Levels.LeanBasics.L05_apply
msgid "apply"
msgstr ""

#: Game.Levels.LeanBasics.L05_apply
msgid "# apply\n"
"Theorems will often have the form of an implication.\n"
"Given a theorem of the form `h : A → B`, we can either `apply` it to a hypothesis\n"
"of the form `ha : A` to turn it into `ha : B`,\n"
"or apply it to the goal if it has the form `B`, turning it into `A`."
msgstr ""

#: Game.Levels.LeanBasics.L05_apply
msgid "Use `apply «{hAB}» at «{hA}»`. Alternatively, use `apply «{hAB}»`\n"
"so that the antecedent of the implication `«{hAB}»` becomes our new goal."
msgstr ""

#: Game.Levels.LeanBasics.L05_apply
msgid "`exact «{hA}»` will close the goal now."
msgstr ""

#: Game.Levels.LeanBasics.L05_apply
msgid "`exact «{hA}»` will close the goal now."
msgstr ""

#: Game.Levels.LeanBasics.L05_apply
msgid "While we mostly use `rw` to make use of our available theorems and\n"
"hypotheses, `apply` will sometimes be useful in cases where a simple `rw` does\n"
"not fit what we want to achieve."
msgstr ""

#: Game.Levels.LeanBasics.L06_have
msgid "have"
msgstr ""

#: Game.Levels.LeanBasics.L06_have
msgid "# have\n"
"Sometimes, we want to construct sub-hypotheses of our own. We can do this with the\n"
"`have` tactic."
msgstr ""

#: Game.Levels.LeanBasics.L06_have
msgid "We could solve this directly with `apply`, but let's see what it looks\n"
"like when we construct a new hypothesis.\n"
"\n"
"Looking at `«{hAB}»` and `«{hA}»`, it is obvious that `«{B}»` should follow.\n"
"Introduce the new hypothesis with the following:\n"
"\n"
"`have hB : «{B}»`"
msgstr ""

#: Game.Levels.LeanBasics.L06_have
msgid "As we can see in the proof state window, we have introduced a new\n"
"goal that we are working towards. Once we have solved our currently\n"
"active goal, we will return back to our main goal, with the freshly\n"
"proved hypothesis at our disposal."
msgstr ""

#: Game.Levels.LeanBasics.L06_have
msgid "There are several ways of solving this,\n"
"but `exact «{hAB}» «{hA}»` will solve the goal directly."
msgstr ""

#: Game.Levels.LeanBasics.L06_have
msgid "As we can see in our proof state, the new hypothesis `hB` is now\n"
"available to us. Let's use it to close out the goal!"
msgstr ""

#: Game.Levels.LeanBasics.L06_have
msgid "Among other possibilities, `exact «{hBC}» «{hB}»` will\n"
"close the goal."
msgstr ""

#: Game.Levels.LeanBasics.L06_have
msgid "Good!"
msgstr ""

#: Game.Levels.LeanBasics.L07_clear
msgid "exact"
msgstr ""

#: Game.Levels.LeanBasics.L07_clear
msgid "# clear\n"
"Sometimes, especially when proving a lemma via `have`, the proof state might include a\n"
"lot of hypotheses that are not necessary to achieve the current goal. To keep them from\n"
"distracting us, we can use the `clear` tactic to remove them."
msgstr ""

#: Game.Levels.LeanBasics.L07_clear
msgid "Use `clear «{a}» «{b}» «{c}» «{d}» «{e}» «{f}» «{hy}» «{hz}» «{y}» «{z}»` to remove the unneeded hypotheses"
msgstr ""

#: Game.Levels.LeanBasics.L07_clear
msgid "Use `exact «{h}»` to close the goal."
msgstr ""

#: Game.Levels.LeanBasics.L07_clear
msgid "Good! Clearing hypotheses can also be useful when you wish to use\n"
"tactics involving automation such as `simp_all` - sometimes, such a tactic\n"
"will work better when certain hypotheses are not available to it!"
msgstr ""

#: Game.Levels.LeanBasics.L08_constructor
msgid "exact"
msgstr ""

#: Game.Levels.LeanBasics.L08_constructor
msgid "# Induction\n"
"To work through certain inductive structures, the `constructor` tactic can be useful.\n"
"We will exclusively use it as a way to handle conjunctions appearing in the goal."
msgstr ""

#: Game.Levels.LeanBasics.L08_constructor
msgid "Use `constructor` to split the conjunction we want to prove into two separate goals."
msgstr ""

#: Game.Levels.LeanBasics.L08_constructor
msgid "`exact hx`"
msgstr ""

#: Game.Levels.LeanBasics.L08_constructor
msgid "`exact hy`"
msgstr ""

#: Game.Levels.LeanBasics.L08_constructor
msgid "We will generally use `constructor` for conjunctions, but it works\n"
"for any inductive type."
msgstr ""

#: Game.Levels.LeanBasics.L09_simp
msgid "simp"
msgstr ""

#: Game.Levels.LeanBasics.L09_simp
msgid "# simp\n"
"Using the more elementary tactics `rw`, `apply`, and `exact` to work through proofs\n"
"will quickly become tedious for more involved proofs.\n"
"Lean offers a number of automation tactics that will take care of different steps\n"
"on their own.\n"
"\n"
"In this level, we introduce the `simp` tactic, which simplifies the goal\n"
"or a hypothesis, and can take on a number of lemmas as arguments that\n"
"it will then try to employ."
msgstr ""

#: Game.Levels.LeanBasics.L09_simp
msgid "Use `simp [«{h}»]` to close the goal immediately"
msgstr ""

#: Game.Levels.LeanBasics.L09_simp
msgid "The exact behavior of `simp` can be a little unpredictable if you're\n"
"not used to working with it, but it is very useful to skip over a great number of\n"
"simple, but manual steps."
msgstr ""

#: Game.Levels.LeanBasics.L10_simp_all
msgid "simp_all"
msgstr ""

#: Game.Levels.LeanBasics.L10_simp_all
msgid "# simp_all\n"
"`simp_all` is similar to `simp`, but applies simplification to the goal\n"
"and all hypotheses several times until they can not get simplified further,\n"
"and also has access to all hypotheses in the proof state to carry out its\n"
"simplifications."
msgstr ""

#: Game.Levels.LeanBasics.L10_simp_all
msgid "`simp_all` closes the goal immediately."
msgstr ""

#: Game.Levels.LeanBasics.L10_simp_all
msgid "As the name implies, `simp_all` can be useful not just to try\n"
"and solve the goal directly, but also to simplify the proof state overall,\n"
"which can make it easier to understand how one should proceed with the proof."
msgstr ""

#: Game.Levels.LeanBasics.L11_omega
msgid "omega"
msgstr ""

#: Game.Levels.LeanBasics.L11_omega
msgid "# omega\n"
"The tactic `omega` can solve integer and natural linear arithmetic problems."
msgstr ""

#: Game.Levels.LeanBasics.L11_omega
msgid "Use `omega` to close the goal immediately"
msgstr ""

#: Game.Levels.LeanBasics.L11_omega
msgid "Good!"
msgstr ""

#: Game.Levels.LeanBasics.L12_split_ifs
msgid "split_ifs"
msgstr ""

#: Game.Levels.LeanBasics.L12_split_ifs
msgid "# split_ifs\n"
"The tactic `split_ifs` allows us to handle `if` statements in our goal."
msgstr ""

#: Game.Levels.LeanBasics.L12_split_ifs
msgid "Use `split_ifs with h`."
msgstr ""

#: Game.Levels.LeanBasics.L12_split_ifs
msgid "The goal follows from `«{h}»` via simple arithmetic, so `omega` closes the goal."
msgstr ""

#: Game.Levels.LeanBasics.L12_split_ifs
msgid "Once again the goal follows from `«{h}»`, so use `omega` again."
msgstr ""

#: Game.Levels.LeanBasics.L12_split_ifs
msgid "Good!"
msgstr ""

#: Game.Levels.LeanBasics.L13_use
msgid "use"
msgstr ""

#: Game.Levels.LeanBasics.L13_use
msgid "# use\n"
"We can resolve existential quantifiers with the help of the `use` keyword."
msgstr ""

#: Game.Levels.LeanBasics.L13_use
msgid "We want to set n := 4: `use 4`."
msgstr ""

#: Game.Levels.LeanBasics.L13_use
msgid "`rw [«{hm}»]` or `omega` will solve this goal."
msgstr ""

#: Game.Levels.LeanBasics.L13_use
msgid "Good!"
msgstr ""

#: Game.Levels.LeanBasics.L14_induction
msgid "induction'"
msgstr ""

#: Game.Levels.LeanBasics.L14_induction
msgid "# Induction\n"
"We utilize several inductive structures that we can handle with the `induction'` tactic."
msgstr ""

#: Game.Levels.LeanBasics.L14_induction
msgid "Use `induction' «{n}» with n ih` to start a proof by induction"
msgstr ""

#: Game.Levels.LeanBasics.L14_induction
msgid "`simp` will close the goal."
msgstr ""

#: Game.Levels.LeanBasics.L14_induction
msgid "We now have our induction hypothesis `ih` at our disposal.\n"
"We can just rely on `omega` to close out our goal rather than going for any\n"
"convoluted rewriting."
msgstr ""

#: Game.Levels.LeanBasics.L14_induction
msgid "Both the type `Word` as well as our definitions for it will be\n"
"inductive, so we will make frequent use of `induction'`!"
msgstr ""

#: Game.Levels.LeanBasics.L14_induction
msgid "Assuming `x` is a variable in the local context with an inductive type, `induction' x` applies induction on `x` to the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor and an inductive hypothesis is added for each recursive argument to the constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the inductive hypothesis incorporates that hypothesis as well."
msgstr ""

#: Game.Levels.LeanBasics.L15_rcases
msgid "rcases"
msgstr ""

#: Game.Levels.LeanBasics.L15_rcases
msgid "# rcases\n"
"For some structures, we might just need to match the forms that they can appear in rather than going for a full blown induction."
msgstr ""

#: Game.Levels.LeanBasics.L15_rcases
msgid "Any proposition follows from a contradiction, also known as ex falso quodlibet."
msgstr ""

#: Game.Levels.LeanBasics.L15_rcases
msgid "`n` is a natural number, meaning that it is either 0, or the successor\n"
"of some other natural number `m`. To match on those cases, start with\n"
"`rcases «{n}» with _ | m`."
msgstr ""

#: Game.Levels.LeanBasics.L15_rcases
msgid "We are in the case `n = 0`.\n"
"`«{hpos}»` is an obvious contradiction.\n"
"To utilize that fact, we can `apply False.elim` to change our goal to `False`."
msgstr ""

#: Game.Levels.LeanBasics.L15_rcases
msgid "Since a negation of the form `¬A` is treated like an implication\n"
"`A → False` in Lean, we can `apply «{hpos}»`."
msgstr ""

#: Game.Levels.LeanBasics.L15_rcases
msgid "`rfl` closes the goal"
msgstr ""

#: Game.Levels.LeanBasics.L15_rcases
msgid "We are in the case `n = succ «{m}»` for some natural number «{m}».\n"
"Obviously «{m}» is the number we are looking for, so `use «{m}»`."
msgstr ""

#: Game.Levels.LeanBasics.L15_rcases
msgid "Good!"
msgstr ""

#: Game.Levels.LeanBasics
msgid "Basic Tactics"
msgstr ""

#: Game.Levels.LeanBasics
msgid "This introductory part serves to introduce the tactics we are\n"
"going to need for the rest of this game."
msgstr ""

#: Game.Levels.Lemmas.L01_Introduction
msgid "Introduction: Words"
msgstr ""

#: Game.Levels.Lemmas.L01_Introduction
msgid "# Words\n"
"Formal languages consist of words over some alphabet Σ.\n"
"They are essentially strings consisting of symbols (or characters) in the alphabet.\n"
"For instance, for an alphabet `Σ = {a, b, c}`, `abc`, `aabba`, and `c`\n"
"will be words over that alphabet.\n"
"The empty word `ε` is also considered a word.\n"
"\n"
"From this, our definition of a word in Lean arises:\n"
"```\n"
"inductive Word where\n"
"  | ε\n"
"  | cons (s : Char) (w : Word)\n"
"```\n"
"\n"
"This is an inductive definition: a word is either the empty word `ε`, or\n"
"some symbol together with the rest of the word.\n"
"For example, the word `c` would look like\n"
"`Word.cons 'c' Word.ε`\n"
"and the word `abc` would look like\n"
"`Word.cons 'a' (Word.cons 'b' (Word.cons ('c' Word.ε)))`\n"
"\n"
"# Concatenation\n"
"We can directly introduce the definition for concatenation of words:\n"
"For words `x` and `y`, the concatenation `xy` just consists of the symbols\n"
"of both words directly pasted in succession.\n"
"For example, if `x = ab` and `y = cbc`, then `xy = abcbc`.\n"
"\n"
"In Lean, our definition looks like this:\n"
"```\n"
"def Word.cat (x y : Word) : Word :=\n"
"  match x with\n"
" | .ε => y\n"
" | .cons s x => .cons s (x.cat y)\n"
"```\n"
"We also introduce the notation `x ∘ y` in Lean to signify the concatenation `xy`.\n"
"\n"
"To show how the definition for `Word.cat` is reasonable, let's show that\n"
"the concatenation `ab ∘ c` indeed yields the word `abc`."
msgstr ""

#: Game.Levels.Lemmas.L01_Introduction
msgid "Concatenating a word with ε yields the original word."
msgstr ""

#: Game.Levels.Lemmas.L01_Introduction
msgid "```\n"
"inductive Word where\n"
"  | ε\n"
"  | cons (s : Char) (w : Word)\n"
"```\n"
"\n"
"A word over an alphabet, i.e. a string of symbols from that alphabet."
msgstr ""

#: Game.Levels.Lemmas.L01_Introduction
msgid "```\n"
"def Word.cat (x y : Word) : Word :=\n"
"  match x with\n"
" | .ε => y\n"
" | .cons s x => .cons s (x.cat y)\n"
"```\n"
"\n"
"Concatenation of words: for two words w₁ and w₂, the concatenation w₁ and w₂ yields w₁w₂."
msgstr ""

#: Game.Levels.Lemmas.L01_Introduction
msgid "Solving this goal is merely a matter of rewriting with `Word.cat`\n"
"several times, so `rw [Word.cat, Word.cat, Word.cat]` or `simp [Word.cat]`\n"
"will solve the goal.\n"
"\n"
"If you want, you can also just apply the rewrites separately and observe\n"
"how each rewrite step adheres to the inductive definition of `Word.cat`."
msgstr ""

#: Game.Levels.Lemmas.L01_Introduction
msgid "Since it is an integral part of the pumping lemma, concatenation\n"
"will feature heavily in the upcoming levels."
msgstr ""

#: Game.Levels.Lemmas.L02_cat_eps
msgid "cat_eps"
msgstr ""

#: Game.Levels.Lemmas.L02_cat_eps
msgid "Let's prove a simple lemma: concatenating any word with the empty word should yield the word itself.\n"
"\n"
"Like for most proofs in this world, we will need to utilize `induction'`.\n"
"Recalling our definition of a `Word`, a word `v` will either be the empty\n"
"word `Word.ε`, or have the `Word.cons s w` for some symbol `s`, and some word `w`.\n"
"To match on these possible forms with those exact variable names, we need to use\n"
"`induction' v with s w ih`,\n"
"with `ih` being the name of the induction hypothesis that we'll be able to access\n"
"in the induction step."
msgstr ""

#: Game.Levels.Lemmas.L02_cat_eps
msgid "This proof calls for an induction! Try starting with `induction' w with s w ih`."
msgstr ""

#: Game.Levels.Lemmas.L02_cat_eps
msgid "This is essentially true by definition of `Word.cat`."
msgstr ""

#: Game.Levels.Lemmas.L02_cat_eps
msgid "`rw [Word.cat]`"
msgstr ""

#: Game.Levels.Lemmas.L02_cat_eps
msgid "We are in the induction step, so our original word now has the form\n"
"`Word.cons «{s}» «{w}»`, which corresponds with the variable names we specified\n"
"when we used the `induction'` tactic."
msgstr ""

#: Game.Levels.Lemmas.L02_cat_eps
msgid "`rw [Word.cat, ih]`"
msgstr ""

#: Game.Levels.Lemmas.L02_cat_eps
msgid "Good!"
msgstr ""

#: Game.Levels.Lemmas.L03_cat_assoc
msgid "cat_assoc"
msgstr ""

#: Game.Levels.Lemmas.L03_cat_assoc
msgid "Let's prove another basic lemma: concatenation is associative."
msgstr ""

#: Game.Levels.Lemmas.L03_cat_assoc
msgid "Concatenation of words is associative, e.g. (x ∘ y) ∘ z = x ∘ (y ∘ z)."
msgstr ""

#: Game.Levels.Lemmas.L03_cat_assoc
msgid "Once again, start with `induction' «{x}» with s w ih`."
msgstr ""

#: Game.Levels.Lemmas.L03_cat_assoc
msgid "Either rewrite with `Word.cat` multiple times, or just\n"
"use `simp [Word.cat]`."
msgstr ""

#: Game.Levels.Lemmas.L03_cat_assoc
msgid "Rewriting with `Word.cat` and then with `ih` works, or just use `simp_all [Word.cat]`."
msgstr ""

#: Game.Levels.Lemmas.L03_cat_assoc
msgid "Good! Incidentally, we've just shown that strings together with concatenation form a monoid."
msgstr ""

#: Game.Levels.Lemmas.L04_cat_chars
msgid "cat_chars"
msgstr ""

#: Game.Levels.Lemmas.L04_cat_chars
msgid "The newly introduced definition `Word.chars w` produces a set\n"
"containing all of the characters occuring in the word `w`:\n"
"\n"
"```\n"
"def Word.chars : (w : Word) → Set Char\n"
"  | ε => ∅\n"
"  | cons s w => {s} ∪ w.chars\n"
"```\n"
"\n"
"As we can see from the definition, the empty word `ε` contains no symbols at all.\n"
"Meanwhile, for a word of the form `Word.cons s w`, we determine the characters contained in `w`,\n"
"and add `s` that set.\n"
"\n"
"\n"
"Let's show that for a concatenated word `xy`, its character set is equal\n"
"to the union of the character sets of each subword."
msgstr ""

#: Game.Levels.Lemmas.L04_cat_chars
msgid "```\n"
"def Word.chars : (w : Word) → Set Char\n"
"  | ε => ∅\n"
"  | cons s w => {s} ∪ w.chars\n"
"```\n"
"\n"
"The set of all characters occuring in a particular word."
msgstr ""

#: Game.Levels.Lemmas.L04_cat_chars
msgid "Forming the union over three sets is associative."
msgstr ""

#: Game.Levels.Lemmas.L04_cat_chars
msgid "The set of characters in a word is the union of all sets of characters\n"
"in its subwords."
msgstr ""

#: Game.Levels.Lemmas.L04_cat_chars
msgid "Start with `induction' x with s w ih`"
msgstr ""

#: Game.Levels.Lemmas.L04_cat_chars
msgid "You can either rewrite with fitting definitions and then `simp`,\n"
"or directly give those definitions as arguments to `simp`."
msgstr ""

#: Game.Levels.Lemmas.L04_cat_chars
msgid "`simp [Word.cat, Word.chars]` closes the goal."
msgstr ""

#: Game.Levels.Lemmas.L04_cat_chars
msgid "You can go for similar rewrites here, though you will need the\n"
"induction hypothesis «{ih}» as well. You might find the theorem\n"
"`Set.union_assoc` useful at some point, which has been added to the `Minor Lemmas`\n"
"tab in your inventory on the right."
msgstr ""

#: Game.Levels.Lemmas.L04_cat_chars
msgid "Start with `rw [Word.chars, Word.cat, Word.chars, ih]`."
msgstr ""

#: Game.Levels.Lemmas.L04_cat_chars
msgid "`rw [Set.union_assoc]` closes the goal now."
msgstr ""

#: Game.Levels.Lemmas.L04_cat_chars
msgid "Good!"
msgstr ""

#: Game.Levels.Lemmas.L05_cons_cat_cancel
msgid "cons_cat_cancel"
msgstr ""

#: Game.Levels.Lemmas.L05_cons_cat_cancel
msgid "For characters `c, d` and words `x, y`, the equality `cx = dy` should result\n"
"in the equalities `c = d` and `x = y`.\n"
"Arriving at either equality is essentially equivalent to canceling the other side of the\n"
"original equation."
msgstr ""

#: Game.Levels.Lemmas.L05_cons_cat_cancel
msgid "Canceling from either the right or left side when two words are equal."
msgstr ""

#: Game.Levels.Lemmas.L05_cons_cat_cancel
msgid "Lean has automatically generated a lemma called `Word.cons.injEq`\n"
"that contains the necessary information for this level, so `simp` will\n"
"close the goal."
msgstr ""

#: Game.Levels.Lemmas.L05_cons_cat_cancel
msgid "Good! We do not strictly need this lemma, but it is good to be aware\n"
"of that property."
msgstr ""

#: Game.Levels.Lemmas.L06_cat_count
msgid "cat_count"
msgstr ""

#: Game.Levels.Lemmas.L06_cat_count
msgid "We've just introduced the `count` definition, which counts how many times a certain character occurs in a word.\n"
"`Word.count w s` is equivalent to the notation `#s(w)` that we will later see in\n"
"the non-regularity proof on paper.\n"
"\n"
"```\n"
"def Word.count (w : Word) (s' : Char) : ℕ := match w with\n"
"  | .ε => 0\n"
"  | .cons s w => if (s = s') then 1 + w.count s' else w.count s'\n"
"```\n"
"\n"
"As we can see, the empty word `ε` always contains zero instances of `s'`.\n"
"For a word of the form `Word.cons s w`, we count how many times `s'` occurs in `w`,\n"
"and then further increment that count by 1 if `s` also matches with `s'`.\n"
"\n"
"Let's show that we can get the count for a character in a word by summing up the counts in its subwords."
msgstr ""

#: Game.Levels.Lemmas.L06_cat_count
msgid "for the concatenation of two words, counting the occurrences of a certain character in the entire word\n"
"is the same as counting the occurrences in both subwords and adding them up."
msgstr ""

#: Game.Levels.Lemmas.L06_cat_count
msgid "```\n"
"def Word.count (w : Word) (s' : Char) : ℕ := match w with\n"
"  | .ε => 0\n"
"  | .cons s w => if (s = s') then 1 + w.count s' else w.count s'\n"
"```\n"
"\n"
"`w.count s` shows `#s(w)`, i.e. the amount of times that the character\n"
"`s` occurs in the word `w`."
msgstr ""

#: Game.Levels.Lemmas.L06_cat_count
msgid "Start with `induction' x with s' w ih`."
msgstr ""

#: Game.Levels.Lemmas.L06_cat_count
msgid "Utilize `Word.cat` and `Word.count`."
msgstr ""

#: Game.Levels.Lemmas.L06_cat_count
msgid "`simp [Word.cat, Word.count]`"
msgstr ""

#: Game.Levels.Lemmas.L06_cat_count
msgid "Remember you can use the tactic `split_ifs` to handle if statements."
msgstr ""

#: Game.Levels.Lemmas.L06_cat_count
msgid "`simp [Word.cat, Word.count]`"
msgstr ""

#: Game.Levels.Lemmas.L06_cat_count
msgid "`split_ifs with h`"
msgstr ""

#: Game.Levels.Lemmas.L06_cat_count
msgid "`omega` will solve this goal directly!"
msgstr ""

#: Game.Levels.Lemmas.L06_cat_count
msgid "`exact «{ih}»` closes the goal immediately."
msgstr ""

#: Game.Levels.Lemmas.L06_cat_count
msgid "Good! We will rely on this lemma quite frequently in the non-regularity proof."
msgstr ""

#: Game.Levels.Lemmas.L07_cat_count_zero
msgid "cat_count_zero"
msgstr ""

#: Game.Levels.Lemmas.L07_cat_count_zero
msgid "We'll need a special case of the lemma we just showed later on: when a certain character does not occur in a word, it won't appear in any of its subwords either."
msgstr ""

#: Game.Levels.Lemmas.L07_cat_count_zero
msgid "If a symbol doesn't occur in the concatenation of two words, then it won't occur in any of the two words either."
msgstr ""

#: Game.Levels.Lemmas.L07_cat_count_zero
msgid "If the sum of two natural numbers is zero, then both of them have to be\n"
"equal to zero."
msgstr ""

#: Game.Levels.Lemmas.L07_cat_count_zero
msgid "Let's start out by introducing the antecedent: `intro hcatcount`"
msgstr ""

#: Game.Levels.Lemmas.L07_cat_count_zero
msgid "To split the conjunction, let's use the `constructor` tactic."
msgstr ""

#: Game.Levels.Lemmas.L07_cat_count_zero
msgid "Use the theorem `Nat.add_eq_zero_iff`, which has been added to your\n"
"inventory."
msgstr ""

#: Game.Levels.Lemmas.L07_cat_count_zero
msgid "simp_all [cat_count, Nat.add_eq_zero_iff]"
msgstr ""

#: Game.Levels.Lemmas.L07_cat_count_zero
msgid "Once again, use the theorem `Nat.add_eq_zero_iff`"
msgstr ""

#: Game.Levels.Lemmas.L07_cat_count_zero
msgid "simp_all [cat_count, Nat.add_eq_zero_iff]"
msgstr ""

#: Game.Levels.Lemmas.L07_cat_count_zero
msgid "Good!"
msgstr ""

#: Game.Levels.Lemmas.L08_cat_len
msgid "cat_len"
msgstr ""

#: Game.Levels.Lemmas.L08_cat_len
msgid "Our new definition `length` defines the length of a word:\n"
"\n"
"```\n"
"def Word.length : (w : Word) → ℕ\n"
" | .ε => 0\n"
" | .cons _ w => 1 + w.length\n"
"```\n"
"\n"
"The empty word `ε` has a length of 0, while for the inductive case `Word.cons s w`\n"
"we do not care about the symbol `s`, always incrementing the length of `w` by 1.\n"
"We also introduce the notation `|w|` for `Word.length w`.\n"
"\n"
"Let's show that the length of a word is equal to the sum of its subwords."
msgstr ""

#: Game.Levels.Lemmas.L08_cat_len
msgid "To determine the length of the concatenation of two words, you can add the length of both words."
msgstr ""

#: Game.Levels.Lemmas.L08_cat_len
msgid "```\n"
"def Word.length : (w : Word) → ℕ\n"
" | .ε => 0\n"
" | .cons _ w => 1 + w.length\n"
"```\n"
"\n"
"The length of a word, i.e. the amount of symbols in it."
msgstr ""

#: Game.Levels.Lemmas.L08_cat_len
msgid "Adding zero to a natural number results in the original number."
msgstr ""

#: Game.Levels.Lemmas.L08_cat_len
msgid "Addition of natural numbers is associative."
msgstr ""

#: Game.Levels.Lemmas.L08_cat_len
msgid "This calls for yet another induction: `induction' x with _ x ih`"
msgstr ""

#: Game.Levels.Lemmas.L08_cat_len
msgid "`Nat.zero_add`, which has been added to your inventory, should be useful\n"
"at some point."
msgstr ""

#: Game.Levels.Lemmas.L08_cat_len
msgid "`simp only [Word.cat, Word.length, Nat.zero_add]`"
msgstr ""

#: Game.Levels.Lemmas.L08_cat_len
msgid "Use `Nat.add_assoc`."
msgstr ""

#: Game.Levels.Lemmas.L08_cat_len
msgid "`simp_all [Word.length, Word.cat, «{ih}», Nat.add_assoc]`"
msgstr ""

#: Game.Levels.Lemmas.L08_cat_len
msgid "Good!"
msgstr ""

#: Game.Levels.Lemmas.L09_pow_len
msgid "pow_len"
msgstr ""

#: Game.Levels.Lemmas.L09_pow_len
msgid "The `pow` definition allows us to create strings of the form aⁿ, such as a⁴ = aaaa:\n"
"\n"
"```\n"
"def Symbol.pow (a : Char) (n : ℕ) : Word :=\n"
"  match n with\n"
"  | 0 => .ε\n"
"  | .succ n => .cons a (Symbol.pow a n)\n"
"```\n"
"\n"
"This inductive definition matches on `n`: if `n` is zero, `Symbol.pow` will result the empty word `ε`.\n"
"If it has the form `n + 1`, then it will result in `Word.cons a aⁿ`.\n"
"We also introduce the notation `a ^ n` for `Symbol.pow a n`.\n"
"\n"
"We want to show that aⁿ is n characters long."
msgstr ""

#: Game.Levels.Lemmas.L09_pow_len
msgid "The length of cⁿ is n for any character c."
msgstr ""

#: Game.Levels.Lemmas.L09_pow_len
msgid "Adding a natural number to one is equal to the successor of that number."
msgstr ""

#: Game.Levels.Lemmas.L09_pow_len
msgid "```\n"
"def Symbol.pow (a : Char) (n : ℕ) : Word :=\n"
"  match n with\n"
"  | 0 => .ε\n"
"  | .succ n => .cons a (Symbol.pow a n)\n"
"```\n"
"\n"
"The power of a symbol: aⁿ = a...a repeated n times."
msgstr ""

#: Game.Levels.Lemmas.L09_pow_len
msgid "```\n"
"def Word.pow (w : Word) (n : ℕ) : Word :=\n"
"  match n with\n"
"  | 0 => .ε\n"
"  | .succ n => w ∘ (w.pow n)\n"
"```\n"
"\n"
"The power of a word: wⁿ = w...w repeated n times."
msgstr ""

#: Game.Levels.Lemmas.L09_pow_len
msgid "This is yet another induction, this time over `«{n}»`:\n"
"`induction' «{n}» with n ih`."
msgstr ""

#: Game.Levels.Lemmas.L09_pow_len
msgid "`rfl` closes the goal immediately."
msgstr ""

#: Game.Levels.Lemmas.L09_pow_len
msgid "The lemma `Nat.one_add` in your inventory will be useful here."
msgstr ""

#: Game.Levels.Lemmas.L09_pow_len
msgid "`simp only [Word.length, «{ih}», Nat.one_add]`"
msgstr ""

#: Game.Levels.Lemmas.L09_pow_len
msgid "Good!"
msgstr ""

#: Game.Levels.Lemmas.L10_pow_count
msgid "pow_count"
msgstr ""

#: Game.Levels.Lemmas.L10_pow_count
msgid "We will now show that for a word of the form cⁿ, it will contain n instances of c, and none of any other character."
msgstr ""

#: Game.Levels.Lemmas.L10_pow_count
msgid "A word of the form cⁿ will contain n instances of the character c, and none of any other character."
msgstr ""

#: Game.Levels.Lemmas.L10_pow_count
msgid "This is another induction: `induction' «{n}» with n ih`."
msgstr ""

#: Game.Levels.Lemmas.L10_pow_count
msgid "`simp [Word.count]`"
msgstr ""

#: Game.Levels.Lemmas.L10_pow_count
msgid "`simp [Word.count]` to introduce the `if` statement in the goal."
msgstr ""

#: Game.Levels.Lemmas.L10_pow_count
msgid "`split_ifs with h`"
msgstr ""

#: Game.Levels.Lemmas.L10_pow_count
msgid "`simp_all` followed by `omega` will close the goal."
msgstr ""

#: Game.Levels.Lemmas.L10_pow_count
msgid "`simp_all` closes the goal."
msgstr ""

#: Game.Levels.Lemmas.L10_pow_count
msgid "Good!"
msgstr ""

#: Game.Levels.Lemmas.L11_pow_cons_count_eq
msgid "pow_cons_count_eq"
msgstr ""

#: Game.Levels.Lemmas.L11_pow_cons_count_eq
msgid "Let's prove a statement for a slightly more complex situation that\n"
"may show up in a non-regularity proof:\n"
"For `n > 0`, characters `c, d`, and words `x, y`, if\n"
"`cx = dⁿy`, then `c` must be `d`!"
msgstr ""

#: Game.Levels.Lemmas.L11_pow_cons_count_eq
msgid "A word of the form cⁿ will contain n instances of the character c, and none of any other character."
msgstr ""

#: Game.Levels.Lemmas.L11_pow_cons_count_eq
msgid "We need to match on `«{n}»` here, so use `rcases «{n}» with _ | n`."
msgstr ""

#: Game.Levels.Lemmas.L11_pow_cons_count_eq
msgid "`«{hn}»` is obviously a contradiction, so `simp at «{hn}»` will close\n"
"the goal immediately."
msgstr ""

#: Game.Levels.Lemmas.L11_pow_cons_count_eq
msgid "This goal follows directly from `«{hcons}»`. Let's first\n"
"`rw [Symbol.pow] at «{hcons}»` to unfold the definition."
msgstr ""

#: Game.Levels.Lemmas.L11_pow_cons_count_eq
msgid "Our previous lemma `cons_cat_cancel` will help here:\n"
"`apply cons_cat_cancel at «{hcons}»`"
msgstr ""

#: Game.Levels.Lemmas.L11_pow_cons_count_eq
msgid "We can now close the goal with `exact «{hcons}».left`."
msgstr ""

#: Game.Levels.Lemmas.L11_pow_cons_count_eq
msgid "Good!"
msgstr ""

#: Game.Levels.Lemmas.L12_pow_cons_count_uneq
msgid "pow_cons_count_uneq"
msgstr ""

#: Game.Levels.Lemmas.L12_pow_cons_count_uneq
msgid "For the last level of this game, let's prove a much more complex statement!\n"
"While it will be much more involved to prove than the other statements in this world,\n"
"it will also be very useful in our non-regularity proof."
msgstr ""

#: Game.Levels.Lemmas.L12_pow_cons_count_uneq
msgid "A word of the form cⁿ will contain n instances of the character c, and none of any other character."
msgstr ""

#: Game.Levels.Lemmas.L12_pow_cons_count_uneq
msgid "This is yet another proof by induction, so start with\n"
"`induction' «{x}» with s x ih generalizing «{n}»`"
msgstr ""

#: Game.Levels.Lemmas.L12_pow_cons_count_uneq
msgid "`rw [Word.count]` will solve this goal immediately."
msgstr ""

#: Game.Levels.Lemmas.L12_pow_cons_count_uneq
msgid "Since we are in the `.cons` case, we can do a bunch of rewrites\n"
"now. Start out with `rw [Word.length] at «{hx}»`, as that will be useful\n"
"later on."
msgstr ""

#: Game.Levels.Lemmas.L12_pow_cons_count_uneq
msgid "We can now look at our goal: `rw [Word.count]`."
msgstr ""

#: Game.Levels.Lemmas.L12_pow_cons_count_uneq
msgid "We now have an if-statement in our goal, with the guard `«{s}» = «{d}»`.\n"
"From our previous lemma `pow_cons_count_eq`, and by looking at `«{hz}»` directly,\n"
"it is already obvious that `«{s}» = «{c}»` has to hold, and since `«{c}» ≠ «{d}»`\n"
"according to `«{huneq}»`, we must have `«{s}» ≠ «{d}»`, meaning that we should\n"
"always land in the `else` case.\n"
"\n"
"We can now employ our previously proved lemma by pattern matching with its\n"
"arguments:\n"
"`have heq := pow_cons_count_eq «{s}» «{c}» «{n}» («{x}» ∘ «{y}») «{z}» «{hz}» (by omega)`."
msgstr ""

#: Game.Levels.Lemmas.L12_pow_cons_count_uneq
msgid "To make use of `«{heq}»` and `«{huneq}»` to land in the `else` case,\n"
"let's use `simp [«{heq}», «{huneq}»]`."
msgstr ""

#: Game.Levels.Lemmas.L12_pow_cons_count_uneq
msgid "As we can see, we need to show that `«{x}»` does not contain any instances\n"
"of the character `«{d}»`, which matches with our goal before the starting the induction.\n"
"However, we now have the induction hypothesis at our disposal!\n"
"\n"
"From here on out, the easiest way forward is to match on `«{n}»`.\n"
"Proceed with `rcases «{n}» with _ | n`."
msgstr ""

#: Game.Levels.Lemmas.L12_pow_cons_count_uneq
msgid "`simp at «{hx}»` closes the goal here, since it produces a contradiction."
msgstr ""

#: Game.Levels.Lemmas.L12_pow_cons_count_uneq
msgid "if we use `«{n}»` for our induction hypothesis `«{ih}»`, we will need to show\n"
"`«{x}» ∘ «{y}» = «{c}» ^ «{n}» ∘ «{z}»`. This follows directly from `«{hz}»`; to show this,\n"
"we first need some rewrites: `rw [Symbol.pow, «{heq}»] at «{hz}»`"
msgstr ""

#: Game.Levels.Lemmas.L12_pow_cons_count_uneq
msgid "We can see that `«{hz}»` precisely matches a previous lemma\n"
"that we can `apply` to it."
msgstr ""

#: Game.Levels.Lemmas.L12_pow_cons_count_uneq
msgid "`apply cons_cat_cancel at «{hz}»`"
msgstr ""

#: Game.Levels.Lemmas.L12_pow_cons_count_uneq
msgid "To use our induction hypothesis `«{ih}»`, we also need to show\n"
"`Word.length «{x}» ≤ «{n}»`; This follows quite obviously from `«{hx}»`, so\n"
"we can just show this with\n"
"\n"
"`have hlen : Word.length «{x}» ≤ «{n}» := by omega`"
msgstr ""

#: Game.Levels.Lemmas.L12_pow_cons_count_uneq
msgid "Close the goal with `exact «{ih}» «{n}» «{hz}».right «{hlen}»`."
msgstr ""

#: Game.Levels.Lemmas.L12_pow_cons_count_uneq
msgid "Very good! You are now prepared to tackle the non-regularity proof in the final\n"
"world."
msgstr ""

#: Game.Levels.Lemmas
msgid "Lemmas"
msgstr ""

#: Game.Levels.Lemmas
msgid "This world is where we introduce the way we formalized the concepts from formal languages that we will require\n"
"later on.\n"
"\n"
"In addition, we will prove a number of lemmas that will be handy for the non-regularity\n"
"proof we are working towards."
msgstr ""

#: Game.Levels.NonregProof.L01_First
msgid "Languages and the Pumping Lemma"
msgstr ""

#: Game.Levels.NonregProof.L01_First
msgid "# Introduction\n"
"In this level, we introduce a number of definitions.\n"
"\n"
"## Languages\n"
"So far, we have been working with individual words made up of arbitrary characters.\n"
"We now look at sets of words over a restricted set of characters, which we call *languages*.\n"
"The new `Language` definition in your inventory shows how we defined languages for our purposes:\n"
"```\n"
"structure Language where\n"
"  Alphabet : Set Char\n"
"  Words : Set Word\n"
"  word_constraint : ∀ word ∈ Words, word.chars ⊆ Alphabet\n"
"```\n"
"One example for a language would be `aⁿbⁿ`, which is the following set over the alphabet `\\{a,b}`:\n"
"`{w | ∃ n : ℕ, w = ('a' ^ n) ∘ ('b' ^ n)}`\n"
"\n"
"## Regular languages and the pumping lemma\n"
"Our goal in the next level will be to show that `aⁿbⁿ` is not regular.\n"
"Regular languages encompass those that can be expressed as DFAs.\n"
"Every regular language satisfies the pumping pumping property, which informally states that each word `z` in that language can be\n"
"split into subwords `u`, `v`, `w`, with `z = uvw`, such that `uvⁱw` will still be contained in the language\n"
"for any `i ∈ ℕ`.\n"
"There are some additional aspects to the pumping property, which are all captured in our definition:\n"
"```\n"
"def pumping_property (L : Language) :=\n"
"  ∃ (n : ℕ),\n"
"  n > 0 ∧\n"
"  ∀ z ∈ L.Words,\n"
"  (hlen : z.length > n) →\n"
"    ∃ (u v w : Word),\n"
"      z = u ∘ v ∘ w ∧\n"
"      |u ∘ v| ≤ n ∧\n"
"      |v| ≥ 1 ∧\n"
"      ∀ (i : ℕ), u ∘ v ^ i ∘ w ∈ L.Words\n"
"```"
msgstr ""

#: Game.Levels.NonregProof.L01_First
msgid "```\n"
"structure Language where\n"
"  Alphabet : Set Char\n"
"  Words : Set Word\n"
"  word_constraint : ∀ word ∈ Words, word.chars ⊆ Alphabet\n"
"```\n"
"\n"
"A language is a set of words over an alphabet."
msgstr ""

#: Game.Levels.NonregProof.L01_First
msgid "```\n"
"def anbn : Set Word := {w | ∃ n : ℕ, w = ('a' ^ n) ∘ ('b' ^ n)}\n"
"```\n"
"\n"
"The set aⁿbⁿ, which is differentiated from the corresponding language by the fact\n"
"that it is not explicitly defined over a restricted alphabet."
msgstr ""

#: Game.Levels.NonregProof.L01_First
msgid "```\n"
"def anbn : Set Word := {w | ∃ n : ℕ, w = ('a' ^ n) ∘ ('b' ^ n)}\n"
"```\n"
"\n"
"The language over the alphabet \\{'a', 'b'} consisting of the set of words of the form aⁿbⁿ."
msgstr ""

#: Game.Levels.NonregProof.L01_First
msgid "```\n"
"def pumping_property (L : Language) :=\n"
"  ∃ (n : ℕ),\n"
"  n > 0 ∧\n"
"  ∀ z ∈ L.Words,\n"
"  (hlen : z.length > n) →\n"
"    ∃ (u v w : Word),\n"
"      z = u ∘ v ∘ w ∧\n"
"      |u ∘ v| ≤ n ∧\n"
"      |v| ≥ 1 ∧\n"
"      ∀ (i : ℕ), u ∘ v ^ i ∘ w ∈ L.Words\n"
"```\n"
"\n"
"The pumping property for regular languages states that each sufficiently long\n"
"word `z` in a regular language may be split as `z = uvw` with certain restrictions\n"
"such that `uvⁱw` will still be in the language for any `i ∈ ℕ`."
msgstr ""

#: Game.Levels.NonregProof.L01_First
msgid "Start with `simp [anbn]`.\n"
"You could also try `rw [anbn]` to replace the definition, but `simp` is nice\n"
"to take care of the `∈` relation in any case."
msgstr ""

#: Game.Levels.NonregProof.L01_First
msgid "`use 2` closes the goal."
msgstr ""

#: Game.Levels.NonregProof.L01_First
msgid "With these new definitions, we can finally try our hand at a non-regularity proof!"
msgstr ""

#: Game.Levels.NonregProof.L02_Proof
msgid "Proving the Non-regularity of aⁿbⁿ"
msgstr ""

#: Game.Levels.NonregProof.L02_Proof
msgid "We are finally ready to work through a proof that utilizes the pumping lemma!\n"
"The proof on paper is as follows:\n"
"\n"
"Let n > 0; we choose z = aⁿbⁿ ∈ anbn, clearly |z| = 2n > n.\n"
"Let u, v, w be words over the alphabet \\{a, b} with z = uvw with |uv| ≤ n\n"
"and |v| ≥ 1.\n"
"We have to show that there is i ∈ ℕ such that uvⁱw ∉ aⁿbⁿ.\n"
"Since |uv| ≤ n and the first n symbols of z are `'a'`s, we know that `#b(v) = 0`.\n"
"Since |v| ≥ 1, there must be at least one a in v, so `#a(v) ≥ 1`.\n"
"So `#a(v) ≠ #b(v)`.\n"
"\n"
"We show that uvvw ∉ aⁿbⁿ by contradiction, so let us assume uvvw ∈ aⁿbⁿ.\n"
"From this `#a(uvvw) = #b(uvvw)` follows directly; since the count of a symbol in a word\n"
"is just the sum of its counts in all its subwords, we thus get the equality\n"
"`#a(u) + #a(v) + #a(v) + #a(w) = #b(u) + #b(v) + #b(v) + #b(w)`.\n"
"Since uvw = z ∈ aⁿbⁿ, we also have `#a(uvw) = #b(uvw)`, leading to the equality\n"
"`#a(u) + #a(v) + #a(w) = #b(u) + #b(v) + #b(w)`.\n"
"Subtracting the latter equality from the former yields `#a(v) = #b(v)`.\n"
"But that is a contradiction with `#a(v) ≠ #b(v)`.\n"
"Therefore, aⁿbⁿ is not regular.\n"
"\n"
"We will want to replicate the structure of the proof in Lean, but it will turn out\n"
"that some of the steps are far more difficult to realize than on paper. Therefore,\n"
"we will mostly guide you through each of the individual steps; you should therefore\n"
"try to follow the instructions closely, as later steps might be contingent on earlier\n"
"ones so that the proof state is in a fitting form."
msgstr ""

#: Game.Levels.NonregProof.L02_Proof
msgid "We use this basic lemma for the simple statement `'a' ≠ 'b'`."
msgstr ""

#: Game.Levels.NonregProof.L02_Proof
msgid "Within the context of our proof, this lemma shows that the characters contained in v\n"
"are either 'a' or 'b'."
msgstr ""

#: Game.Levels.NonregProof.L02_Proof
msgid "Let's first `rw [pumping_property]` to recall the definition of the pumping\n"
"property, then `push_neg` to push the negation all the way in."
msgstr ""

#: Game.Levels.NonregProof.L02_Proof
msgid "`push_neg`"
msgstr ""

#: Game.Levels.NonregProof.L02_Proof
msgid "We can now replicate the initial 'let n > 0' part of the proof with `intro n hpos`."
msgstr ""

#: Game.Levels.NonregProof.L02_Proof
msgid "The word we want to use is z = aⁿbⁿ.\n"
"Let's introduce it with `set z : Word := ('a' ^ n) ∘ 'b' ^ n with hz`.\n"
"Afterwards, we can use it for our proof with `use z`."
msgstr ""

#: Game.Levels.NonregProof.L02_Proof
msgid "`use z`"
msgstr ""

#: Game.Levels.NonregProof.L02_Proof
msgid "`constructor` will split the conjunction into separate goals."
msgstr ""

#: Game.Levels.NonregProof.L02_Proof
msgid "We need to show that the word we have chosen is actually contained\n"
"in the language aⁿbⁿ. We can first unfold the definition with `simp [anbn_lang, anbn]`."
msgstr ""

#: Game.Levels.NonregProof.L02_Proof
msgid "`use «{n}»` closes the goal immediately."
msgstr ""

#: Game.Levels.NonregProof.L02_Proof
msgid "We once again use `constructor` to handle the conjunction."
msgstr ""

#: Game.Levels.NonregProof.L02_Proof
msgid "We need to show that the length of z is indeed greater than n. You can\n"
"`rw` or simp step by step with some of the lemmas that we showed in the previous world,\n"
"and then use the `omega` tactic once you arrive at a proof state of the form\n"
"`n + n > n`."
msgstr ""

#: Game.Levels.NonregProof.L02_Proof
msgid "The exact hypotheses for rewriting that you should use\n"
"are `«{hz}»`, `cat_len`, `pow_len`, and `pow_len` again.\n"
"\n"
"As an alternative to rewriting, you can also just `simp [«{hz}», cat_len, pow_len]`, and\n"
"`omega` afterwards."
msgstr ""

#: Game.Levels.NonregProof.L02_Proof
msgid "`omega` closes the subgoal."
msgstr ""

#: Game.Levels.NonregProof.L02_Proof
msgid "We can finally get to the main part of the proof! First of all, we need\n"
"to introduce all the conditions that we also introduce in the paper proof:\n"
"\n"
"`intro u v w hcons hlenlower hv`"
msgstr ""

#: Game.Levels.NonregProof.L02_Proof
msgid "Let's look at our hypotheses:\n"
"- `«{u}»`, `«{v}»`, and `«{w}»` are the newly introduced words\n"
"- `hcons` states that `«{z}» = «{u}»«{v}»«{w}»`, so we have indeed split `«{z}»`\n"
"into three subwords\n"
"- `«{hlenlower}»` represents the assumption `|«{u}»«{v}»| ≤ n`\n"
"- `«{hv}»` represents the other assumption `|«{v}»| ≥ 1`\n"
"\n"
"These are all exactly the same assumptions that we introduced at this point\n"
"in our proof!\n"
"\n"
"We now need to provide a suitable `i`; in the paper proof we chose `i = 2`,\n"
"so let's `use 2`."
msgstr ""

#: Game.Levels.NonregProof.L02_Proof
msgid "In our paper proof, we made an argument for why there are no `'b'`s in\n"
"`«{v}»`. For our formalization, let's have this as a separate hypothesis:\n"
"\n"
"`have hnobs : «{v}».count 'b' = 0`"
msgstr ""

#: Game.Levels.NonregProof.L02_Proof
msgid "Let's simplify the entire proof state with\n"
"`simp_all [«{z}»]`"
msgstr ""

#: Game.Levels.NonregProof.L02_Proof
msgid "The argument in our proof implicitly works by showing that there are\n"
"no `'b'`s in `uv`. Let's show that first: `have huv : (u ∘ v).count 'b' = 0`."
msgstr ""

#: Game.Levels.NonregProof.L02_Proof
msgid "We need to utilize the associativity that we proved earlier:\n"
"\n"
"`rw [← cat_assoc] at hcons`\n"
"\n"
"Following that, use the tactic `symm at «{hcons}»`"
msgstr ""

#: Game.Levels.NonregProof.L02_Proof
msgid "For this specific situation, we have already proved the lemma `pow_cons_count_uneq`,\n"
"so you can finish the subproof with\n"
"\n"
"`apply pow_cons_count_uneq 'a' 'b'\n"
"(ne_of_beq_false rfl) «{n}» («{u}» ∘ «{v}») «{w}» ('b' ^ «{n}») «{hcons}» «{hlenlower}»`"
msgstr ""

#: Game.Levels.NonregProof.L02_Proof
msgid "We can now use the fresh hypothesis `«{huv}»`, utilizing the lemma `cat_count_zero`\n"
"that we showed earlier:\n"
"\n"
"`exact (cat_count_zero «{u}» «{v}» «{huv}»).right`"
msgstr ""

#: Game.Levels.NonregProof.L02_Proof
msgid "For the next step of our proof, we showed that `«{v}»` contained at least\n"
"one `'a'`. This will unfortunately be much more involved to show!\n"
"\n"
"`have hatleastonea : «{v}».count 'a' > 0`"
msgstr ""

#: Game.Levels.NonregProof.L02_Proof
msgid "Since `«{v}»` is a subword of `«{z}»`, and `«{z}» ∈ aⁿbⁿ`, it is obvious that the\n"
"characters contained in `«{v}»` have to either be `'a'` or `'b'`. Showing this is a slightly\n"
"involved proof since it involves some manual handling of sets - therefore, we have\n"
"already provided this hypothesis in the form of the lemma `v_subset_ab`:\n"
"\n"
"`have hvchars := v_subset_ab «{hz}» «{hcons}»`"
msgstr ""

#: Game.Levels.NonregProof.L02_Proof
msgid "We have a lot of unnecessary hypotheses, so let's remove them:\n"
"\n"
"`clear «{hlenlower}» «{hcons}» «{hz}» «{u}» «{w}» «{z}» «{hpos}» «{n}»`"
msgstr ""

#: Game.Levels.NonregProof.L02_Proof
msgid "The fact that `«{v}»` contains at least 1 `'a'` should follow quite\n"
"obviously from `«{hv}»`, `«{hnobs}»` and `«{hvchars}»`:\n"
"Due to `«{hv}»`, `«{v}»` contains at least one symbol, which according to `«{hvchars}»` is either\n"
"`'a'` or `'b'`.\n"
"But since `«{v}»` contains no `'b'`s according to `«{hnobs}»`, that symbol must then be `'a'`!\n"
"\n"
"We still need to do the rest of the work to show our statement. Let's pattern match\n"
"on `«{v}»` with `rcases v with _ | ⟨s, w⟩`."
msgstr ""

#: Game.Levels.NonregProof.L02_Proof
msgid "`«{hv}»` states that our word should have a length of at least 1, but\n"
"the empty word `ε` has a length of 0, meaning that we get a contradiction\n"
"in our hypotheses. As we can achieve any goal from a false hypothesis,\n"
"this is exactly what we want!\n"
"\n"
"To reduce «{hv}» to false, just use `simp [Word.length] at «{hv}»`, which\n"
"will also do some additional steps that end up closing the goal directly."
msgstr ""

#: Game.Levels.NonregProof.L02_Proof
msgid "Let's use `simp_all [Word.length, Word.count]` to simplify our proof state."
msgstr ""

#: Game.Levels.NonregProof.L02_Proof
msgid "At this point, we don't specifically care about the fact that `«{w}».count 'a'`\n"
"specifically describes how many `'a'`s there are in «{w}» - we just care about the fact that\n"
"it is some arbitrary natural number. We can therefore make the proof state a bit more\n"
"readible by generalizing it into some number `n`:\n"
"\n"
"`generalize «{w}».count 'a' = m at *`"
msgstr ""

#: Game.Levels.NonregProof.L02_Proof
msgid "We can now look at at the if statement in our goal: `split_ifs with hs`."
msgstr ""

#: Game.Levels.NonregProof.L02_Proof
msgid "This inequality is obviously true for any «{n}», so let's solve it directly\n"
"with `omega`."
msgstr ""

#: Game.Levels.NonregProof.L02_Proof
msgid "According to `«{hvchars}»`, `«{s}»` is either `'a'` or `'b'`, and\n"
"`«{hs}»` states that `«{s}»` is not `'a'` - therefore, `«{s}»` must be `'b'`! Let's show this\n"
"as a new hypothesis:\n"
"\n"
"`have hsb : «{s}» = 'b'`"
msgstr ""

#: Game.Levels.NonregProof.L02_Proof
msgid "Let's remove the unrequired elements: `clear «{hnobs}» «{n}»`."
msgstr ""

#: Game.Levels.NonregProof.L02_Proof
msgid "We want to mutate `«{hvchars}»` into a form where it essentially\n"
"directly states that `«{s}»` is either `'a'` or `'b'`, so that `simp_all` can take care\n"
"of the rest.\n"
"\n"
"Start with `rw [Word.chars] at «{hvchars}»`."
msgstr ""

#: Game.Levels.NonregProof.L02_Proof
msgid "We can apply a preexisting theorem that shows how unions interact with subsets:\n"
"\n"
"`apply Set.union_subset_iff.mp at «{hvchars}»`"
msgstr ""

#: Game.Levels.NonregProof.L02_Proof
msgid "From here on out, the proof state contains enough information that `simp_all`\n"
"will close the goal."
msgstr ""

#: Game.Levels.NonregProof.L02_Proof
msgid "With the new hypothesis `«{hsb}»` we land in the `if` case in `hnobs`, which\n"
"will be the statement `1 + Word.count «{w}» 'b' = 0`.\n"
"\n"
"This statement is a contradiction, so `simp [«{hsb}»] at «{hnobs}»` will\n"
"close the goal."
msgstr ""

#: Game.Levels.NonregProof.L02_Proof
msgid "We can now work through the main step of the proof. We want to show\n"
"a negated statement. For a statement `φ`, its negation `¬φ` will be equivalent to\n"
"`φ → False` in Lean, so our goal is actually an implication right now. We therefore want to\n"
"proceed by introducing the antecedent: `intro hin`."
msgstr ""

#: Game.Levels.NonregProof.L02_Proof
msgid "Let's simplify the newly introduced hypothesis so it's in a form that's more useful to\n"
"us: `simp [Word.pow, cat_eps] at «{hin}»`."
msgstr ""

#: Game.Levels.NonregProof.L02_Proof
msgid "To make several of our hypotheses easier to read, let's proceed with another\n"
"simplification: `simp_all [cat_assoc, «{z}»]`."
msgstr ""

#: Game.Levels.NonregProof.L02_Proof
msgid "After this last `simp_all`, our proof state contains some hypotheses\n"
"that are no longer necessary. Let's remove them with `clear «{hlenlower}» «{hv}» «{hpos}» «{z}»`."
msgstr ""

#: Game.Levels.NonregProof.L02_Proof
msgid "Our hypothesis `«{hin}»` states that `uvvw` is a word in the language\n"
"`aⁿbⁿ`. Let's understand what this means exactly with `simp [anbn_lang, anbn] at «{hin}»`."
msgstr ""

#: Game.Levels.NonregProof.L02_Proof
msgid "Since `uvvw` is in `aⁿbⁿ`, there must be some `n` such that `uvvw = aⁿbⁿ`. Let's access\n"
"this `n` with `rcases «{hin}» with ⟨m, hm⟩`."
msgstr ""

#: Game.Levels.NonregProof.L02_Proof
msgid "Our goal is to show some sort of contradiction now. The idea is that\n"
"due to `«{hm}»`, the number of `'a'`s and `'b'`s in `uvvw` has to be equal. But according to\n"
"`«{hcons}»`, `«{hnobs}»`, and `«{hatleastonea}»`, those counts have to be different!\n"
"\n"
"Let's show the first statement now:\n"
"`have heven : («{u}» ∘ «{v}» ∘ «{v}» ∘ «{w}»).count 'a' = («{u}» ∘ «{v}» ∘ «{v}» ∘ «{w}»).count 'b'`"
msgstr ""

#: Game.Levels.NonregProof.L02_Proof
msgid "This statement should follow quite directly from `«{hm}»`, but is a little convoluted\n"
"to prove manually, so we want to employ `simp` once again.\n"
"Let's open by rewriting with `«{hm}»`: `rw [«{hm}»]`."
msgstr ""

#: Game.Levels.NonregProof.L02_Proof
msgid "Remember that we stated the lemma `cat_count` to handle counts of concatenations,\n"
"and further `pow_count` to state that `#a(aⁿ) = n`. These two facts are obviously enough to\n"
"show the goal right now, so let's just close it directly with\n"
"`simp [cat_count, pow_count]`."
msgstr ""

#: Game.Levels.NonregProof.L02_Proof
msgid "The more involved proof will be to use the previously proven hypotheses\n"
"to show that the number of `'a'`s in `«{u}»«{v}»«{v}»«{w}»` differs from the number of `'b'`s.\n"
"We first want to show that `«{u}»«{v}»«{w}»` indeed has the same amount of `'a'`s and `'b'`s.\n"
"\n"
"`have hcount : («{u}» ∘ «{v}» ∘ «{w}»).count 'a' = («{u}» ∘ «{v}» ∘ «{w}»).count 'b'`"
msgstr ""

#: Game.Levels.NonregProof.L02_Proof
msgid "This is based on the fact that `«{u}»«{v}»«{w}» = aⁿbⁿ`, so let's substitute it back with\n"
"`rw [← «{hcons}»]`."
msgstr ""

#: Game.Levels.NonregProof.L02_Proof
msgid "Our proof state is almost exactly the same as at the end of our previous hypothesis\n"
"`heven`, so the lemmas `cat_count` and `pow_count` are essentially enough to solve the\n"
"goal:\n"
"\n"
"`simp [cat_count, pow_count]`"
msgstr ""

#: Game.Levels.NonregProof.L02_Proof
msgid "Since both `«{u}»«{v}»«{w}»` and `«{u}»«{v}»«{v}»«{w}»` have the same count of `'a'`s\n"
"and `'b'`s, «{v}» must have the same count as well:\n"
"\n"
"`have hveqcount : «{v}».count 'a' = «{v}».count 'b'`"
msgstr ""

#: Game.Levels.NonregProof.L02_Proof
msgid "The two hypotheses that the goal should intuitively follow from are `«{hcount}»` and\n"
"`«{heven}»`, so let's transform them into sums with `simp [cat_count] at hcount heven`."
msgstr ""

#: Game.Levels.NonregProof.L02_Proof
msgid "Our goal follows from subtracting the equality `«{hcount}»` from the other\n"
"equality `«{heven}»`, which is also what we do in our paper proof at this point.\n"
"Since this is a simple arithmetic problem, we can close the goal\n"
"with `omega`."
msgstr ""

#: Game.Levels.NonregProof.L02_Proof
msgid "The previous hypotheses we showed were only steps to get to\n"
"`«{hveqcount}»`; to have a clearer view of what we actually need, let's remove them again:\n"
"\n"
"`clear «{heven}» «{hcount}» «{hm}» «{m}» «{hcons}»`."
msgstr ""

#: Game.Levels.NonregProof.L02_Proof
msgid "The contradiction we now receive boils down to the fact that according\n"
"to `«{hveqcount}»`, `«{v}»` contains as many `'a'`s as `'b'`s, but according to `«{hnobs}»` and\n"
"`«{hatleastonea}»`, that number should be different.\n"
"\n"
"At this point our hypotheses contain enough information that `simp_all` or `omega` will\n"
"close the goal, but if you want you can try to go for a more manual approach."
msgstr ""

#: Game.Levels.NonregProof.L02_Proof
msgid "You just went through an entire non-regularity proof!"
msgstr ""

#: Game.Levels.NonregProof.L02_Proof
msgid "`set` is hidden anyway, so this docstring is just a placeholder"
msgstr ""

#: Game.Levels.NonregProof
msgid "Non-regularity Proof"
msgstr ""

#: Game.Levels.NonregProof
msgid "In this world, you will work through a full non-regularity proof yourself!"
msgstr ""

#: Game
msgid "Proof Game for the Pumping Lemma"
msgstr ""

#: Game
msgid "# A Proof Game for the Pumping Lemma\n"
"\n"
"Welcome to the proof game for the pumping lemma!\n"
"This game aims to teach you the basics of working through\n"
"non-regularity proofs for regular languages using the pumping lemma.\n"
"\n"
"Due to the somewhat complex nature of such proofs we assume some base familiarity with Lean.\n"
"Nonetheless, since we give optional hints for every single step required to go\n"
"through all the levels, this game might still be of some use to you even if you\n"
"have not worked with Lean before.\n"
"\n"
"Start by clicking on the first world, `Basic Tactics`, which offers a refresher on the tactics we\n"
"are going to need for this game.\n"
"\n"
"Mind that the introduction to the second world appears empty due to some unknown bug."
msgstr ""

#: Game
msgid "This game is part of my Bachelor's thesis at LMU Munich.\n"
"\n"
"The [original code can be found on github](https://github.com/nlohrer/proof-game-pumping-lemma)\n"
"\n"
"## Credits\n"
"\n"
"* **Creators:** Norman Lohrer\n"
"* **Game Engine:** Alexander Bentkamp, Jon Eugster, Patrick Massot"
msgstr ""

#: Game
msgid "A proof game for the pumping lemma."
msgstr ""

#: Game
msgid "In this game you learn how to work through non-regularity proofs for regular languages\n"
"in Lean by applying the pumping lemma."
msgstr ""
